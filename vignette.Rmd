---
title: "Application of the scp pipeline to adult cardiomyocytes data"
author:
- name: Sven Berres
  affiliation: Medical Bioinfomratics, University Bochum, Germany
- name: Louise Buur
  affiliation: Bioinformatics Research Group, University of Applied Sciences Upper Austria, Austria
- name: Laurent Gatto
  affiliation: de Duve Institute, UCLouvain, Belgium
- name: Enrico Massignani
  affiliation: CompOmics, UGent, Belgium
- name: Sam van Puyenbroeck
  affiliation: CompOmics, UGent, Belgium
- name: Christophe Vanderaa
  affiliation: statOmics, UGent, Belgium
- name: Hannah Voß
  affiliation: Immunoproteomics (AG Shevchuck), University Clinic Essen, Germany
package: QFeatures
abstract: >
 Application of the `scp` pipeline to the adult cardiomyocytes data
 from Ai /et al./ (2025). This vignette is distributed under a CC BY-SA license.
output:
  BiocStyle::html_document:
    toc: true
    toc_float: true
    toc_depth: 2
    code_folding: show
date: "`r BiocStyle::doc_date()`"
bibliography: ai2025.bib
vignette: >
  %\VignetteIndexEntry{Application of the scp pipeline on adult cardiomyocytes data}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r style, echo = FALSE, results = 'asis'}
BiocStyle::markdown()
```

# Introduction

In this vignette, we will reanalyse single-cell proteomics data from
[@Ai2025].

## Motivation of the original paper

iPSC-derived cardiomyocytes (iCMs) have been proposed as a model to
study cardiovascular diseases. However, this requires that iCMs
display the same biological features as adult cardiomyocytes
(aCMs). The authors of the manuscript used MS-based single-cell
proteomics to analyze metabolic changes in iPSCs during
differentiation process and to compare the resulting iCMs to
freshly-isolated aCMs.

Here, we will focus on the analysis of the aCMs data.

## Data origin

Single cardiomyocytes were isolated from 3 human hearts using
enzymatic digestion isolation technique.

Cells were isolated from 4 regions of the heart, labelled **LVepi**
(left ventricle, epi-myocardium), **LVendo** (left ventricle,
endo-myocardium), **LVmid** (left ventricle, mid-myocardium), and
**RV** (right ventricle).

Single cell proteomes were analyzed in a label-free approach. MS data
was acquired in data-independent mode (DIA-MS).


Data were analyzed with DIA-NN 1.8.1 and DIA-NN 1.8.2. The DIA-NN
reports were downloaded from MassIVE (MSV000094438).

#### Packages

The following packages were used to compile this vignette.

```{r setup, eval = TRUE, message = FALSE, warning = FALSE}
library(scp)
library(tidyverse)
library(patchwork)
```

# Data prepartion and processing

We can now read in the results file from DIA-NN. We use the file
`report.tsv` file generate by DIA-NN (renamed `aCMs_report.zip` below).

```{r readreport, eval = TRUE, cache = TRUE, message = FALSE}
acmsTab <- read_tsv("./data/aCMs_report.zip")
```

We can use the `readSCPfromDIANN` to have an initial look at the data.

```{r readscp0, eval = FALSE}
acms <- readSCPfromDIANN(acmsTab)
acms
```

Doing this, we already create a `QFeatures` object, but we want
extract additional metadata from the file names.

We want to extract:
-   File name
-   Sample name
-   Acquisition date
-   Subject number
-   Location in the heart from which each cell was extracted (Lvendo,
    Lvepi, Lvmid, RV, sytox)
-   Position in the 384 well plate
-   Position (BA18, ...)

We see that `acms` object contains 299 assays (which means that 299
cells were analysed).

Our goal is then to create a data frame with 299 rows, one for each
cell, with the information defined above as the columns.

```{r metadata, eval = TRUE}
## Extracting file name, sample name, date, subject, well position and
## position
tab <- tibble(File.Name = unique(acmsTab[[1]])) |>
  mutate(Sample = sub("^.+CM_PROJECT\\\\", "", File.Name)) |>
  mutate(Sample = sub("\\\\", "_", Sample)) |>
  mutate(Date = ymd(as.integer(substring(Sample, 1, 6)))) |>
  mutate(Subject = sub("^.+_(Subject[0-9])_.+$", "\\1", Sample)) |>
  mutate(PlateWell = sub("^.+_([A-Z][0-9]+)_.+$", "\\1", Sample)) |>
  mutate(Position = sub("^.+_([A-Z]+[0-9]+)_1_[0-9]+\\.d$", "\\1", Sample))

## Getting the plate letters
tab$PlateLetter <- substring(tab$PlateWell, 1, 1)

## Extracting the heart locations
tab$HeartLocation <- NA
ExpectedLocations <- c("Lvendo", "Lvepi", "Lvmid", "RV", "sytox")
for (i in 1:5) {
  loc <- ExpectedLocations[i]
  tab$HeartLocation[grep(loc, tab$File.Name, ignore.case = TRUE)] <- loc
}
```

After creating the data frame we can check that the values in the
different columns.

```{r, eval = TRUE}
table(tab$Subject)
table(tab$HeartLocation)
table(tab$Date)
```

We can see that there are 21 cells from Subject5, 21 cells that falls
into the "sytox" category and that 21 cells were analysed on one
specific date. And running the code below, we can indeed see that all
samples from Subject5 were analysed on the same date, and that all of
these cells falls into the "sytox" category of the `HeartLocation`
column.

```{r, eval = TRUE}
table(tab[, c("Date","Subject")])
table(tab[, c("HeartLocation","Subject")])
```

Sytox is a stain used for assessing cell viability, and we can
therefore remove these cells before we start doing statistical
analysis.

To create the `QFeatures` object, we need to add a column `runCol` to
properly associate the `colData` to each sample.

```{r, eval = TRUE}
tab$runCol <- tab$File.Name
```

Now we can create the `QFeatures` object, and include the metadata
that we extracted. We also use the `fnames` argument to use percursor
identifiers (i.e. peptides sequence and precursor charge) as assay
rownames (this is important to correctly join the assays below).

```{r readscp, eval = TRUE, cache = TRUE}
acms <- readSCPfromDIANN(acmsTab,
                         colData = DataFrame(tab),
                         fnames = "Precursor.Id")
# Setting the names of the QFeatures objects
names(acms) <- acms$Sample
acms
```

Note that the `fnames` requires `QFeatures` version 1.17.2 or later.

```{r checkversion, echo = FALSE}
stopifnot(packageVersion("QFeatures") >= "1.17.2")
```

Replace 0 by `NA` for downstream analysis.

```{r naIsZero, eval = TRUE, cache = TRUE}
acms <- zeroIsNA(acms, names(acms))
```

Like the authors of the paper, we will remove all the precursors that
have been mapped to protein groups. Having peptides that map to more
than one protein will make quantitative analysis more complicated.

```{r rmpg, eval = FALSE}
## ";" in the protein name indicate that the identified peptide maps
## to more than one protein
(acms <- filterFeatures(acms, ~ !grepl(";", Protein.Names)))
```

If you wish, you can also do further filtering of the data, for
instance the posterior error probability (PEP) or the protein
Q-values.

```{r morefiltering, eval = FALSE}
acms |>
  filterFeatures(~ !grepl(";", Protein.Names)) |>
  filterFeatures(~ PEP < 0.01) |>
  filterFeatures(~ Protein.Q.Value < 0.05)
```

Lastly, before the quality control and exploratory data analysis, we
can to join all the assays based on the precursors.

```{r joinPrecursors, cache = TRUE}
(acms <- joinAssays(acms, i = names(acms), name = "precursors"))
```

# Exploratory data analysis

# Quality control

Use the `precursors` assay, created above.

- Compute the median intensity for each cell
- Compute the number of identifications (non NA values) in each cell
- Compute the median CV per cell (see `medianCVperCell()`)

We then visualise each of these to identify low quality cells that
could be removed.

```{r cellqc}
  acms$MedianIntensity <- colMedians(
      assay(acms[["precursors"]]), na.rm = TRUE
  )

  acms$TotalIds <- colSums(!is.na(assay(acms[["precursors"]])))

  acms <- medianCVperCell(
    acms,
    i = "precursors",
    groupBy = "Protein.Names",
    nobs = 3,
    na.rm = TRUE,
    colDataName = "MedianCV"
  )
```

```{r cellqc1}
  colData(acms) |>
    data.frame() |>
    ggplot(aes(x = log10(MedianIntensity),
               y = TotalIds,
               colour = MedianCV)) +
    geom_point(size = 4)
```

```{r cellqc2}
colData(acms) |>
    data.frame() |>
    ggplot(aes(x = log10(MedianIntensity),
               y = TotalIds,
               colour = Subject)) +
    geom_point(size = 4) +
    colData(acms) |>
    data.frame() |>
    ggplot(aes(x = log10(MedianIntensity),
               y = TotalIds,
               colour = HeartLocation)) +
    geom_point(size = 4)
```

```{r cellqc3}
  colData(acms) |>
    data.frame() |>
    ggplot(aes(x = log10(MedianIntensity),
               y = TotalIds,
               colour = factor(Date))) +
    geom_point(size = 4)
```

```{r cellqc4}
colData(acms) |>
    data.frame() |>
    mutate(PlateNumber = as.numeric(substr(PlateWell, 2, 3))) |>
    ggplot(aes(x = PlateNumber,
               y = PlateLetter,
               fill = HeartLocation)) +
    geom_tile()
```

# Data processing

We start by log-transforming our data for downstream statistical
analyses. The `logTransfrorm()` function will create a new assay,
named `precursors_log`.

```{r logtrans, eval = TRUE}
(acms <- logTransform(acms, "precursors", "precursors_log"))
```

While we will be performing our analyses with precursor data, below we
show how to aggregate these data into peptide and protein data.

```{r aggregation1, eval = TRUE}
acms <- aggregateFeatures(acms,
                          i = "precursors_log",
                          name = "peptides",
                          fcol = "Modified.Sequence",
                          fun = colMedians,
                          na.rm = TRUE)
acms[["peptides"]]
```


```{r aggregation2, eval = TRUE}
acms <- aggregateFeatures(acms,
                          i = "peptides",
                          name = "proteins",
                          fcol = "Protein.Ids",
                          fun = colMedians,
                          na.rm = TRUE)
acms[["peptides"]]
```

# Statistical modelling

We will model the data following the *scplainer* pipeline
[@Vanderaa2023-scplainer].

## Modelling

We extract the log-transformed precursor assez and remove sytox cells
(all from subject 5):

```{r sce}
sce <- getWithColData(acms, "precursors_log")
sce <- sce[, sce$HeartLocation != "sytox"]
```

We can now model the precursor quantities considering median intensity
in each cell, plate position (column), subject and heart location as
factors that influence the measure abundances.

```{r scpmodelling, cache = TRUE}
sce <- scpModelWorkflow(
    sce,
    formula = ~ 1 + ## intercept
        ## normalisation
        MedianIntensity +
        ## batch effects
        PlateLetter +
        Subject +
        ## biological variability
        HeartLocation
)
```

Here, we define the missing data filtering threshold: we want at least
3 measurement for each coefficient estimation.

```{r filterthreshold}
scpModelFilterThreshold(sce) <- 3
scpModelFilterPlot(sce)
scpModelFilterPlot(sce)
```

## Analysis of variance

```{r vaRes, cache = TRUE}
(vaRes <- scpVarianceAnalysis(sce))
```

```{r vaPlot, cache = TRUE}
## Add annotations from the rowData()
vaRes <- scpAnnotateResults(
    vaRes, rowData(sce), by = "feature", by2 = "Precursor.Id"
)

scpVariancePlot(vaRes)

## Two figures on one plot
scpVariancePlot(
    vaRes, top = 20, by = "percentExplainedVar", effect = "Subject",
    decreasing = TRUE, combined = FALSE, fcol = "Protein.Names"
) + scpVariancePlot(
        vaRes, top = 10, by = "percentExplainedVar", effect = "HeartLocation",
        decreasing = TRUE, combined = FALSE, fcol = "Protein.Names"
    ) + plot_layout(ncol = 1, guides = "collect")
```


## Differential abundance analysis

```{r daRes, cache = TRUE}
locations <- unique(sce$HeartLocation)
combinations <- combn(locations, 2)
contrasts <- lapply(1:ncol(combinations),
                    function(i) c("HeartLocation",
                                  combinations[, i]))

(daRes <- scpDifferentialAnalysis(
     sce, contrast = contrasts
 ))
```

```{r daplots}
daRes[[1]]

daRes <-
    scpAnnotateResults(
        daRes, rowData(sce),
        by = "feature", by2 = "Precursor.Id")

scpVolcanoPlot(daRes,
               textBy = "Protein.Names",
               pointParams = list(aes(colour = Lib.Q.Value)))[[1]]
```

## Component analysis

```{r caRes, cache = TRUE}
(caRes <- scpComponentAnalysis(
     sce, ncomp = 15, method = "APCA"))
```

```{r caPlot}
caResCells <- caRes$bySample
sce$cell <- colnames(sce)
caResCells <- scpAnnotateResults(caResCells,
                                 colData(sce), by = "cell")


scpComponentPlot(
    caResCells,
    pointParams = list(aes(colour = HeartLocation,
                           shape = Subject),
                       size = 3)) |>
    wrap_plots() +
    plot_layout(guides = "collect")
```

```{r tsne}
library(scater)

sce <-addReducedDims(sce, caRes$bySample)
sce <- runTSNE(sce, dimred = "APCA_HeartLocation")

plotTSNE(sce, colour_by = "HeartLocation") +
    plotTSNE(sce, colour_by = "Subject") +
    plotTSNE(sce, colour_by = "PlateLetter") +
    plotTSNE(sce, colour_by = "MedianIntensity")
```

We can not extract the hear location effect matrix, removing the
subject, plate position and median intensity effects for downstream
analysis.

```{r scebr}
scebr <- scpRemoveBatchEffect(
  sce, effects = c("Subject", "PlateLetter", "MedianIntensity"),
  intercept = TRUE)
```


# Downstream analyses

# Session information

This vignette pas prepared as part of the [EuBIC 2025 developer
hackathon](https://eubic-ms.org/events/2025-developers-meeting/).

```{r hackathon, echo = FALSE, caption = "Hackathon participants, from left to right: Sven Berres, Hannah Voß, Louise Buur, Sam van Puyenbroeck, Christophe Vanderaa, Laurent Gatto and Enrico Massignani"}
knitr::include_graphics("figs/IMG_6152.jpg")
```

using the follwing software

```{r si, echo = FALSE}
sessionInfo()
```

# References {-}